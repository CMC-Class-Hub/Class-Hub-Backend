name: CI-CD

on:
  # ✅ develop, main 으로 PR 들어오면 CI
  pull_request:
    branches: [ "develop", "main" ]

  # ✅ main에 push(merge 포함) 오면 CI + CD
  push:
    branches: [ "main" ]

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: classhub-backend
  CONTAINER_NAME: classhub-api
  APP_PORT: "8080"

jobs:
  # =========================
  # ✅ CI: 테스트 + JAR 빌드
  # - PR(develop/main): CI만
  # - main push: CI 실행 후 CD까지 진행됨
  # =========================
  ci:
    runs-on: ubuntu-latest

    steps:
      # 1) 레포 코드를 러너에 내려받음
      - name: Checkout
        uses: actions/checkout@v4

      # 2) gradlew 실행 권한 부여 (리눅스에서 종종 필요)
      - name: Grant execute permission for Gradle Wrapper
        run: chmod +x ./gradlew

      # 3) Java 17 설치
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      # 4) Gradle 캐시/최적화 설정 (빌드 속도 개선)
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      # 5) 테스트 실행 (실패하면 CI 실패)
      - name: Test
        run: ./gradlew test

      # 6) 빌드 실행 (실행 가능한 Spring Boot JAR 생성)
      - name: Build bootJar
        run: ./gradlew clean bootJar -x test

      # ✅ main push일 때만 CD에서 쓸 jar를 artifact로 저장
      # (PR 때는 CI만 하니까 굳이 업로드할 필요 없음)
      - name: Upload jar artifact (only main push)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: build/libs/*.jar
          retention-days: 3

  # =========================
  # ✅ CD: main push일 때만 실행
  # - CI 성공 후
  # - jar 받아서 Docker 이미지 생성 → ECR Push → EC2 실행
  # =========================
  cd:
    runs-on: ubuntu-latest
    needs: ci

    # ✅ main push일 때만 실행되도록 강제
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    permissions:
      contents: read
      id-token: write  # ✅ OIDC로 AWS Role Assume 할 때 필요 (AccessKey 없이 인증)

    steps:
      # 1) Dockerfile을 쓰려면 레포 코드가 필요함
      - name: Checkout (for Dockerfile)
        uses: actions/checkout@v4

      # 2) CI에서 저장한 jar artifact 다운로드
      - name: Download jar artifact
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: artifact

      # 3) Dockerfile에서 COPY하기 좋게 app.jar로 복사
      - name: Prepare jar file for docker build
        run: |
          JAR_PATH=$(ls artifact/*.jar | head -n 1)
          cp "$JAR_PATH" app.jar

      # 4) GitHub Actions → AWS 인증 (OIDC 방식)
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      # 5) ECR 로그인
      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 6) Docker 이미지 빌드 + ECR 푸시
      - name: Build & Push Docker image to ECR
        run: |
          REGISTRY="${{ steps.ecr.outputs.registry }}"
          IMAGE="$REGISTRY/${{ env.ECR_REPOSITORY }}:${{ github.sha }}"
          LATEST="$REGISTRY/${{ env.ECR_REPOSITORY }}:latest"

          docker build -t "$IMAGE" .
          docker tag "$IMAGE" "$LATEST"

          docker push "$IMAGE"
          docker push "$LATEST"

          echo "IMAGE=$IMAGE" >> $GITHUB_ENV

      # 7) EC2에서 최신 이미지 Pull 후 컨테이너 재시작
      - name: Deploy on EC2 (SSH)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e

            IMAGE="${{ env.IMAGE }}"
            REGION="${{ env.AWS_REGION }}"
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            APP_PORT="${{ env.APP_PORT }}"

            echo "[1] Login to ECR"
            aws ecr get-login-password --region "$REGION" \
              | docker login --username AWS --password-stdin $(echo "$IMAGE" | cut -d/ -f1)

            echo "[2] Pull new image"
            docker pull "$IMAGE"

            echo "[3] Stop & Remove old container"
            docker stop "$CONTAINER_NAME" || true
            docker rm "$CONTAINER_NAME" || true

            echo "[4] Run new container"
            docker run -d \
              --name "$CONTAINER_NAME" \
              --restart always \
              -p "$APP_PORT:8080" \
              "$IMAGE"

            echo "[DONE] Deployed: $IMAGE"
